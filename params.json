{"name":"Kettle","tagline":"A different approach to building views using Backbone + jQuery","body":"# Kettle\r\n\r\nKettle is a library for writing UI elements in javascript using Backbone's Model/Collection/Routers.\r\n\r\n##Overview\r\n\r\nThe Kettle library attempts to facilitate a different approach to writing views, where each view is seen as a set of independent elements that share a common model(s)\r\nand are mapped 1:1 to a DOM Element.\r\n\r\nEach element is thought of as a separate unit that performs a very specific role within a view, it does so by responding to events. These events would typically come from the\r\nuser (click, mouseover,etc) or from a model/collection/router.\r\n\r\nThis approach allows for views to be declarative , decoupled and efficient at rendering and re-rending themselves upon change.\r\n\r\nHave a look at 'examples/todoMVC' for an example and a general idea of how this achieved with Kettle.\r\n\r\n## Size/Version\r\n\r\nUncompressed size: 73761 bytes.  \r\nCompressed size: 4885 bytes gzipped (24117 bytes minified).  \r\nVersion: 0.1  \r\nProduction Ready: false  \r\n\r\n## Dependencies\r\n\r\n* underscore/lodash\r\n* jQuery/Zepto\r\n* Backbone\r\n\r\n## Example\r\n\r\nPlain HTML templates:\r\n```html\r\n<div id=\"todos\">\r\n    <h3>My Todos:</h3>\r\n    <input type=\"text\" data-kettle=\"newTodo\"/>\r\n    <button data-kettle=\"addTodo\">Add Todo</button>\r\n    <div data-kettle=\"todoList\"></div>\r\n    <button data-kettle=\"removeCompleted\">Remove Completed</button>\r\n</div>\r\n\r\n<script id=\"item\" type=\"text/template\">\r\n    <div>\r\n        <input type=\"checkbox\" data-kettle=\"completed\"/>\r\n        <input type=\"text\" data-kettle=\"title\"/>\r\n        <button data-kettle=\"remove\">X</button>\r\n    </div>\r\n</script>\r\n```\r\n\r\nThe javascript:\r\n```javascript\r\n$(function(){\r\nvar TodoItem = Kettle.View.extend({\r\n    el: '#item',\r\n    \"model.destroy\" : function() {\r\n        this.remove();\r\n    },\r\n    elements : {\r\n        \"completed\" : 'model.completed',\r\n\r\n        \"title\" : {\r\n            bind : 'model.title',\r\n            \"model.change:completed\" : function(model, completed) {\r\n                this.$el.prop('disabled', completed);\r\n            }\r\n        },\r\n\r\n        \"remove\" : {\r\n            \"el.click\" : function() {\r\n                this.model.destroy();\r\n            }\r\n        }\r\n    }\r\n});\r\n\r\nvar Todos = Kettle.View.extend({\r\n    el: '#todos',\r\n    state : { \"newTodo\": ''},\r\n    elements : {\r\n        \"newTodo\": 'state.newTodo',\r\n\r\n        \"todoList\" : {\r\n            subviews : TodoItem\r\n        },\r\n\r\n        \"addTodo\" : {\r\n            \"el.click\" : function() {\r\n                this.collection.add({\r\n                    title : this.state.get('newTodo'),\r\n                    completed: false\r\n                });\r\n\r\n                this.state.set('newTodo', '');\r\n            }\r\n        },\r\n\r\n        \"removeCompleted\" : {\r\n            \"el.click\" : function() {\r\n                _.invoke(this.collection.where({completed: true}), 'destroy');\r\n            },\r\n            \"collection[add remove reset change:completed]\" : function() {\r\n                this.$el.toggle(this.collection.where({completed : true}).length > 0);\r\n            }\r\n        }\r\n\r\n    }\r\n});\r\n\r\nvar tasks = [\r\n    {title: \"Make js library\", completed: true}, \r\n    {title : \"Make it production ready\", completed: false}\r\n];\r\n\r\nvar todos = new Todos({collection: new Backbone.Collection(tasks), state: {newTodo: \"What's next?\"}});\r\n\r\nvar newTasks = [\r\n    {title: \"Go outside.\", completed: false}\r\n];\r\n\r\n//swap the old collection with the new one, re-rending the view with the new task.\r\ntodos.set('collection', new Backbone.Collection(newTasks));\r\n\r\n});\r\n\r\n```\r\n## View\r\n\r\nA *view* consists of any number of child *elements*. Each *element* of the *view*\r\nis its own separate object responsible for only itself and should not be able to access any other *element*\r\nof the *view*. (Although this is not strictly enforced).\r\n\r\nA *view* is represented by a single DOM element, each of the *view* child *elements* are also represented by a single DOM element that\r\nare contained within the *view* DOM element\r\n\r\nA *view* requires a plain html template in order to be rendered, a template can either be provided on the *view*\r\ndefinition, the instantiation, or both, with the template provided on instantiation taking precedence.\r\n\r\nExample:\r\n\r\n```html\r\n<div id=\"view\">\r\n    <span data-kettle=\"foo\"></span>\r\n</div>\r\n```\r\n\r\n```javascript\r\nvar View = Kettle.View.extend({\r\n    //Specify the attribute used to identify child elements (default : data-kettle)\r\n    attr : 'data-kettle'\r\n    //The default template to use for this view\r\n    el: '#view', \r\n    //A click event bound to the parent DOM element (top most <div>);\r\n    \"el.click\" : function() { \r\n        //context here resolves to the view itself\r\n        console.log(this);\r\n        //the jquery object reprensting the view topmost DOM element\r\n        console.log(this.$el);\r\n         //object that holds the refrences to all the individual element objects\r\n        console.log(this.elements);\r\n    },\r\n    elements : { \r\n        //List of all the child dom elements that will map to the ones found in the template\r\n        \"foo\" : {\r\n            //a click event bound to views child 'span' element\r\n            \"el.click\" : function(e) {\r\n                //context here resolves to child element object, not the parent view\r\n                console.log(this);\r\n                //this jquery object representing the child's DOM element, not the parent view element\r\n                console.log(this.$el);\r\n                //the parent view\r\n                console.log(this.view); \r\n            },\r\n            //a function to run when a change event fires on the 'model' eventObject\r\n            \"model.change\" : function() {} \r\n        }\r\n    }\r\n});\r\n```\r\n## Event Objects\r\n\r\nA *view* can have any number of subscriptions to any number of *event objects*.\r\n*event objects* are javascript objects that can trigger events. They are the core of a Kettle *view*.\r\nCurrently that includes anything that mixes in with `Backbone.Events` or that is a `jQuery`/`Zepto` object.\r\n\r\nA *view* subscribes to events by referencing an *event object* by name. The view holds a record of each event that it subscribes to.\r\nThis allows for swapping an *event object* under the same name, which will unbind all subscribed events on the old *event object* and binding them\r\nto the new one. Individual *elements* of a *view* will have their own subscriptions but will share the *event objects* with their parent *view*.\r\nWith the exception of the `'el'` *event object*, which is unique to each *element* and is its own `jQuery`/`Zepto` object.\r\n\r\nAside from the `'el'` *event object* a *view* (and all of its *elements*) also has the `'view'` *event object* which is the *view* itself.\r\n\r\n*event objects* can be accessed from the `'eventObjects'` property on both the *view* and its *elements*.\r\n`'model'`, `'collection'` and `'state'`are also available as a direct property of the *view*/*element* for convenience, as they are most common.\r\n\r\n*event objects* can be set upon instantiation of a view :\r\n\r\n```javascript\r\nnew View({eventObjects: { someModel: aModel, someCollection: a Collection}});\r\n```\r\n\r\nThe `'model'`, `'collection'` and `'state'` event Objects can also be passed at the root of the options object.\r\n\r\n```javascript\r\nnew View({model: aModel}); //same as bellow\r\nnew View({eventObjects : {model: aModel}});\r\n```\r\n*event objects* can also be set via the `set` method after instantiation:\r\n\r\n```javascript\r\nview.set('model', newModel);\r\n```\r\n\r\nWhere the first parameter is the name and the second is the *event object*. Upon setting a new *event object* the view will re-render itself accordingly.\r\n\r\n\r\n## General Structure\r\n\r\nKettle uses its own structure to define a *view* and its *elements*. The structure attempts to give focus to each individual element and the \r\nevents that they respond to.\r\n\r\n### Events Structure\r\n\r\nWhen defining a *view*, events can be written in either dot or bracket notation.\r\n\r\n#### Dot Notation\r\n\r\n`eventObject.eventName`\r\n\r\nEvents can be bound to a *view* or its *elements* using the dot notation. Where the name before the dot is the name of the\r\n*event object*. The word after the dot is the name of the event, For example: `model.change` or `model.change:attribute`\r\n\r\n#### Bracket Notation\r\n\r\n`eventObject[eventName1 eventName2]`\r\n\r\nEvents can also be bound using the bracket notation. This allows for easily binding multiple events on the same *event object*.\r\nThe word before the brackets is the name of the *event object* while the words in the brackets, which are separate by a space\r\nare the event names. For example: 'collection[add remove reset]'\r\n\r\n### Properties\r\n\r\nBelow is a list of valid properties that can be defined on a *view*/*elements*\r\n\r\n#### On both the *view* and *element*  \r\n\r\ndot-notation events: events bound to the view/element in the dot-notation.  \r\nbracket-notation events: events bound to the view/element in the bracket-notation  \r\n`group`: a group or array of groups that the view/element inherits its behavior from  \r\n`setup`: a method (or array of methods) that will be called after this element/view has been instantiated, typically to modify `el`  \r\n\r\n#### Only on the *view*:  \r\n\r\n`state` : an object literal of all the default values that get initially set for the view's state model.  \r\n`model` : the primary model Constructor of the view (if applicable, used for type-checking)  \r\n`collection` : the primary collection Constructor of the view (if applicable, used for type checking)  \r\n`eventobjects` : an object literal of all other *event objects* Constructors  \r\n`elements` : the list of elements belonging to the view  \r\n`groups` : a list of groups belonging to the view  \r\n`attr` : the attribute used to load the *elements* from the template (default 'data-kettle')  \r\n`el` : the default element/template to use for this view  \r\n`initialize(args)` : the initialization function to be called for the view, with the parameters passed in from `new`  \r\n\r\n#### Only on the *element*:  \r\n\r\n`bind`: a string in the notation of `eventObject.attribute` or an object literal containing options for two way binding.  \r\n`subviews`: 'either a flag, an object literal with options or a view constructor, which indicate that this element is a view collection  \r\n`subview`: either a flag, an object literal with options or a view constructor, which indicate that this element is a view container  \r\n`template`: a flag or a selector indicating that this element is a template  \r\n\r\nNote: only one of `bind`, `subview`, `subviews`, `template` can exists on an individual element.  \r\n\r\n### Other Properties\r\n\r\nProperties that are not expected by the Kettle parsers (any property not listed in the above), will added to the instance instead.\r\n\r\n```javascript\r\nvar View = Kettle.View.extend({\r\n    'foo' : 'bar',\r\n});\r\n\r\nvar view = new View();\r\nconsole.log(view); //bar\r\n```\r\n## View State\r\n\r\nAt times your *view* will require its own state, one which is specific to the *view* and thus does not belong on a model. For example,\r\na folder view may have a display state, where the values can either be 'minimal' or 'detailed'. If you specify a `state` property\r\nwithin the *view* than Kettle will automatically create a `Backbone.Model` for you which will represent the view state.\r\nYou can then use the state like you would any other model.\r\n\r\nExample: \r\n\r\n```javascript\r\nvar FolderView = Kettle.View.extend({\r\n    state : {\r\n        display: 'detailed'\r\n    },\r\n    elements : {\r\n        icon : {/*...*/},\r\n        name : {/*...*/},\r\n        filesize : {\r\n            \"state.change:display\" : function(state, display) {\r\n                this.$el.toggle(display === 'detailed');\r\n            }\r\n        }\r\n    }\r\n});\r\n\r\nvar folder = new FolderView({state : {display : 'minimal'}});\r\n```\r\n\r\nSince a state is just a Backbone.Model it can be passed around from one view to another, in order to share state or to load your view\r\nin a particular starting state. Or to have a mediator/controller listen in to the state of a view and perform an action when there's a change.\r\n\r\n## View Events\r\n\r\nA view extends from Backbone.Events and triggers some built in events:\r\n\r\n`change (view, name, newEventObject, oldEventObject)` - When an *event object* has been changed  \r\n`change:name (view, newEventObject, oldEventObject)` - When a specific *event object* has been changed, e.g.: `change:model`  \r\n`render (view)` - When the view has been rendered  \r\n`remove (view)` - When a view has been removed  \r\n\r\n## Groups\r\n\r\nAt times you will have multiple *elements* that perform the same action for a particular event, these *elements* can be\r\nlogically grouped together so that they can share behaviors:\r\n\r\n```javascript\r\nKettle.View.extend({\r\n    elements : {\r\n        \"saveButton\" : {\r\n            \"model.change:editing\" : function(model, editing) {\r\n                this.$el.toggle(editing === true);\r\n            },\r\n            \"el.click\" : function(e) {//save logic}\r\n        },\r\n        \"deleteButton\" : {\r\n            \"model.change:editing\" : function(model, editing) {\r\n                this.$el.toggle(editing === true);\r\n            },\r\n            \"el.click\" : function(e) {//delete logic}\r\n        }\r\n    }\r\n});\r\n```\r\n\r\nIn the above example both the save and delete buttons get their visibility toggled when the editing attribute on the model\r\nchanges, resulting in duplicated code. Since both of these *elements* appear to share behaviour we can group them together.\r\n\r\n\r\n```javascript\r\nKettle.View.extend({\r\n    groups : {\r\n        \"editableItem\" : {\r\n            \"model.change:editing\" : function(model, editing) { \r\n                this.$el.toggle(editing === true);\r\n            }\r\n        }\r\n    },\r\n    elements : {\r\n        \"saveButton\": {\r\n            group: 'editableItem',\r\n            \"el.click\" : function(e) {//save logic}\r\n        },\r\n        \"deleteButton\" : {\r\n            group: 'editableItem',\r\n            \"el.click\" : function(e) {//delete logic}\r\n        }\r\n    }\r\n});\r\n```\r\n\r\nIn the above example we group the save and delete buttons together and have them share common functionality.\r\nAn *element* can also belong to a list of groups by specifying the groups within an Array.\r\n\r\n### Global Groups\r\n\r\nGroups can also be defined on a global level to be available to every View. This can be done with the `setGroup(groupName, data)`\r\non the `Kettle` object. e.g. `Kettle.setGroup('global-group', {})`, There are also `getGroup(groupName)` and `removeGroup(groupName)`\r\nif you need to modify existing groups.\r\n\r\n### Anonymous Groups\r\n\r\nAn *element* can also share functionality without formally defining a group, by using space separated property names:\r\n\r\n```javascript\r\nKettle.View.extend({\r\n    elements : {\r\n        \"saveButton deleteButton\" : {\r\n           \"model.change:editing\" : function(model, editing) {\r\n                this.$el.toggle(editing === true);\r\n            }\r\n        },\r\n        \"saveButton\": {\r\n            \"el.click\" : function(e) {//save logic}\r\n        },\r\n        \"deleteButton\" : {\r\n            \"el.click\" : function(e) {//delete logic}\r\n        }\r\n    }\r\n});\r\n```\r\n\r\n## Multi-Property declarations\r\n\r\nMultiple properties of an *element* can also share the same value by separating the properties with a space.\r\n\r\nExample demonstrating making an event alias.\r\n\r\n```javascript\r\nKettle.View.extend({\r\n    elements : {\r\n        \"list\" : {\r\n            subviews: true,\r\n            \"collection.add addItem\": function(model) {\r\n                this.addView({model: model});\r\n            },\r\n            \"collection.reset\" : function() {\r\n                this.collection.each(this.addItem,this);\r\n            }\r\n        }\r\n    }\r\n});\r\n```\r\n\r\nExample demonstrating binding multiple events to the same method\r\n\r\n```javascript\r\n{\r\n    \"model1.change model2.change\" : function(model, val, options) {}\r\n}\r\n```\r\n\r\n## View Collection\r\n\r\nA *collection view* manages a variable number of *sub views*, a *collection view* can be defined by setting the `subviews` property on an element\r\ndeclaration. It will typically manage *sub views* automatically for you given a `Backbone.Collection`. Events such as `add`, `remove`, `reset` \r\nand `sort` will be handled by the *collection view*. By default the *collection view* will assume to operate on a `Backbone.Collection`\r\ncalled `\"collection\"` and a model called `\"model\"` on each of the *sub views*. Manual control of *sub views* may also be enabled.\r\n\r\nA `ViewCollections` is also able to listen to events on any *event object* of the added *sub views*. To listen to a *sub views* *event object*\r\nprepend an event in dot or bracket notation with a '\\*' character.\r\n\r\n```javascript\r\nKettle.View.extend({\r\n    elements : {\r\n        \"list\" : {\r\n            subviews: AView //Where \"AView\" is a view constructor\r\n            \"*view.change\" : function(view) {\r\n                console.log(\"This event came from a subview\");\r\n            },\r\n            \"*model.change\" : function(model,value){\r\n                console.log(\"This event came from a subview's 'model' eventObject\");\r\n            },\r\n            \"*el.click\" : function(e) {\r\n                console.log(\"This event came from a subviews DOM element\");\r\n            }\r\n        }\r\n    }\r\n});\r\n\r\n```\r\n\r\nIf you need to specify how the *sub views* gets constructed than you can use the `create` property:\r\n\r\n```javascript\r\nKettle.View.extend({\r\n    elements : {\r\n        \"list\" : {\r\n            subviews : {\r\n                create : function(model) {\r\n                    return new AView({model : model});\r\n                }\r\n            }\r\n        }\r\n    }\r\n});\r\n```\r\n\r\nThe `create` property is a function that accepts a `Backbone.Model` and expects a new *view* to be returned, this way you can control exactly how\r\neach *view* in the *collection view* gets instantiated.\r\n\r\nOther options that can be part of the `subviews` are:\r\n\r\n`View` : the *view* constructor to be used for automatic instantiation by the *collection view*  \r\n`create`: the function used to instantiate new views in the *collection view* given a `Backbone.Model`  \r\n`collection`: the name of the `Backbone.Collection` *event object* that will be used to manage *sub views*. default : `'collection'`  \r\n`model` : the name of the model used by each *sub view*. default: `'model'`  \r\n`empty`: A *view* that will be displayed if there are no *sub views* currently in the *collection view*  \r\n\r\nNote: if you wish to manually manage *sub views* without having events automatically bound for you, you can do so by omitting either\r\nthe `create` or `view` properties, or by simply setting `subviews : true`\r\n\r\n## View Container\r\n\r\nA *container view* can hold exactly one *view*. That *view* can either be predetermined upon instantiation or after. It can be swapped for another *view* at\r\nany time. Much like the *collection view*, a *container view* can listen to its child *view* for any events it emits or any events emitted by the\r\n*event objects* it has. \r\n\r\nA *container view* can be defined on an element by including the `subview` property.\r\n\r\nBy default a *sub view* will receive all the *event objects* of the *container view*, and will get them updated if ever the *container view* changes its\r\n*event objects* (but not vise-versa).\r\n\r\n```javascript\r\nKettle.View.extend({\r\n    elements : {\r\n        \"container\": {\r\n            subview : AView\r\n        }\r\n    }\r\n});\r\n```\r\n\r\nIf you need to specify how the *sub view* gets constructed than you can use the `'set'` property:\r\n\r\n```javascript\r\nKettle.View.extend({\r\n    elements : {\r\n        \"container\" : {\r\n            subview : {\r\n                set : function() {\r\n                    return new AView();\r\n                }\r\n            }\r\n        }\r\n    }\r\n});\r\n```\r\n\r\nOther options that can be passed into the `subview` are :\r\n\r\n`View`: the view constructor to be used for automatic instantiation by the container\r\n`set`: the function used to instantiate a new *view* in the container\r\n`sync`: whether the *sub view* will automatically possess the *event objects* of the *container view*\r\n\r\nNote: to not set any *sub view* initially but to indicate that the *element* is indeed a *container view* you can set the `subview` property to `true`.\r\n\r\n## Template View\r\n\r\nA *template view* is a view that is able to render a template (by default underscore templates). *template view* is a good fit for when you have DOM elements\r\nthat are tied to model attributes but with little interaction. On a *template view* events can only be easily bound on the top level element. To enable an element\r\nto be a *template view* set the `template` property on an element definition. A value of `true` will grab the template code from inside the DOM element.\r\nAlternatively a selector can be used as well to grab the template from within another script tag.\r\n\r\n\r\n```html\r\n<div id=\"view\">\r\n    <div data-kettle=\"contact\">Name : <%= name %> - Phone : <%= phone %><div>\r\n</div>\r\n```\r\n\r\n```javascript\r\nKettle.View.extend({\r\n   el: '#view',\r\n   elements : {\r\n        name : {\r\n            template : true,\r\n            \"model.change\" : function(model, name) {\r\n                this.renderTemplate(model.toJSON());\r\n            }\r\n        }\r\n   }\r\n});\r\n\r\nvar view = new View({model: {name : \"Jane Doe\", phone : \"555-5555\"}});\r\n```\r\n\r\n## Two-way binding\r\n\r\nTwo-way binding in Kettle can be enabled by setting the bind property to an object within an element definition.\r\n\r\nThe properties that can be set on the bind object are:  \r\n    'eventObject' - the name of the eventObject that that the binding will apply to. default : 'model'  \r\n    'attribute' - the name of the attribute that will be two-way binded on the eventObject. default : same as element name.  \r\n    'domEvent' - the dom event that needs to get trigged for the eventObject to get updated. default: 'change'  \r\n\r\nNote: as a convenience if the bind value is set to `true` it is equivalent to `{}`, meaning all default values will be used.  \r\n\r\nA string will also be accepted in the format `model.attribute`, where 'model' is the name of the *event object* and 'attribute' is\r\nthe attribute that you wish to bind to on it.\r\n\r\n\r\n### Custom binding methods\r\n\r\nYou can also declare your own functions that describe how a model attribute binds to a DOM element and vice-versa. This can be\r\nuseful when dealing with a `jQuery` widget for example.\r\n\r\nTo override the default behaviour of 2-way binding you can use the following properties within a `bind`:  \r\n    `fromDOM` - a function that given an object containing binding data will return a function that performs the binding from DOM->Model  \r\n    `fromModel` - a function that given an object containing binding data will return a function that performs the binding from Model->DOM  \r\n\r\nExample: you want to use the `jQuery` datepicker widget for a date field and store the values as epoch times in your model  \r\n\r\n``` javascript\r\nKettle.setGroup(\"datepicker\", {\r\n    setup : function() {\r\n        this.$el.datepicker();\r\n    },\r\n    bind : {\r\n        fromDOM : function(binding) {\r\n            return function(e) {\r\n                var epoch = +this.$el.datepicker(\"getTime\"),\r\n                    model = this.eventObject[binding.eventObject];\r\n\r\n                model.set(binding.attribute, epoch);\r\n            }\r\n        },\r\n        fromModel : function(binding) {\r\n            return function(model, epoch, options) {\r\n                this.$el.datepicker(\"setTime\", epoch);\r\n            }\r\n        }\r\n    }\r\n});\r\n\r\nKettle.View.extend({\r\n    elements : {\r\n        \"date1\" : {\r\n            group: 'datepicker',\r\n            bind: 'model.startDate'\r\n        },\r\n        \"date2\" : {\r\n            group : 'datepicker',\r\n            bind: 'model.endDate',\r\n\r\n        },\r\n        \"date3\" : {\r\n            group : 'datepicker',\r\n            bind: 'model.otherDate'\r\n        }\r\n    }\r\n});\r\n\r\n```\r\n\r\n## View Rendering\r\n\r\nThe render method on a *view* is optional, meaning a *view* is able to render itself by default based\r\non the events it responds to. During the rending phase the *view* is bootstrapped by running certain\r\nevent delegated methods, these methods are ran as though they are originated from the *event object* itself.\r\nEssentially they are \"faked\" for the purpose of bootstrapping the *view* in the proper initial state.\r\n\r\nNote: When events are faked during the rendering phase the 'bootstrap' property\r\nin the options object is present and set to 'true', in case the event delegated method ever\r\nneeds to distinguish between a real and \"fake\" event.\r\n\r\n### Rendering Events\r\n\r\nUpon initialization, any *view* or *element* that subscribe the following events will automatically be called.\r\n\r\n#### Backbone.Model\r\n* `change`\r\n* `change:*`\r\n* `add` (only if part of a collection)\r\n* `all`\r\n\r\n#### Backbone.Collection\r\n* `reset`\r\n* `all`\r\n\r\n#### Backbone.Router\r\n* `route` (only called if the last called route was triggered by the same router)\r\n* `route:*` (same as above but also if the route matches the last called route)\r\n\r\n\r\n## Event Execution Order\r\n\r\nEvents attached to a *view* or its *elements* are not guaranteed to execute in any particular order. Therefore your methods should not\r\nrely on any kind of order of execution. The only order that is guaranteed is that events on the *view* will execute before any of\r\nthe child *elements*.\r\n\r\n## Global Event Objects\r\n\r\nIf your application has a global *event object*, such as the `Backbone` event bus or a app model, you can can have it\r\nautomatically be accessible to every created *view* using `Kettle.setGlobal`.\r\n\r\n```javascript\r\nKettle.setGlobal('Bus', Backbone);\r\n\r\nvar View = Kettle.View.extend({\r\n    \"Bus.log\" : function(msg) {\r\n        console.log(msg);\r\n    }\r\n});\r\n\r\nvar view = new View();\r\nBackbone.trigger(\"log\", \"foo\");\r\n```\r\n## Other Kettle Objects\r\n\r\nThe `Kettle.View` object may  have *elements* that are a *collection view*, *container view*,*template view*, etc, but you can also\r\ndeclare each of those things as its own separate entity. For example if you just want to have a *collection view* with\r\nout any other elements you can extend `Kettle.ViewCollection`, or if you wish to render a simple template you extend a\r\n`Kettle.TemplateView`, etc. Upon extension, the constructors that get returned can even be used as a value to an *element* in a *view*.\r\n\r\n```javascript\r\nvar List = Kettle.CollectionView.extend({\r\n    el: \"#list\",\r\n    subviews : Item,\r\n    \"collection.change\" : function() {},\r\n});\r\n\r\nvar View = Kettle.View.extend({\r\n    el: \"#view\",\r\n    elements :{\r\n        \"list\" : List\r\n    }\r\n})\r\n```\r\n\r\n## Extending Kettle Structure\r\n\r\nYou can extend Kettle's structure to add your own options to all Kettle elements.\r\nTo do so you can call the `add` method on the following objects:\r\n\r\n`Kettle.elementLoader` To add an option for all Kettle Objects  \r\n`Kettle.domValueLoader`  \r\n`Kettle.collectionViewLoader`  \r\n`Kettle.containerViewLoader`  \r\n`Kettles.templateViewLoader`  \r\n`Kettles.viewLoader`  \r\n\r\n\r\n```javascript\r\nKettles.elementLoader.add(function(options) {\r\n    return options.className;\r\n},\r\nfunction(element, className) {\r\n    element.$el.addClass(className);\r\n});\r\n\r\nvar View = Kettle.View.extend({\r\n    className: \"foo\",\r\n    elements : {\r\n        \"foo\" : {\r\n            className : \"foo\"\r\n        }\r\n    }\r\n});\r\n```\r\n\r\nThe `add` method accepts two functions, the first function is the parser function, which will receive all the initial parameters\r\nof the element and return some value. The parser function will execute only upon the initial definition of the element.\r\nThe second function is the builder function which will execute on every instantiation of the element and get the value \r\nreturned by the parser function as its first parameter.\r\n\r\nNote: Returning undefined from the parser function will cause the builder function not to execute.\r\n\r\n\r\n## Extending Kettle Objects\r\n\r\nWhen an *element* gets extended with the `extend` method, not only are you extending the prototype but also the\r\nbehaviour of the parent, any events that were subscribed to on the parent will also be subscribed to on the child.\r\n\r\n```javascript\r\n\r\nvar ParentView = Kettle.View.extend({\r\n    elements : {\r\n        \"foo\" : {\r\n            \"model.change:foo\" : function(m, v) {\r\n                console.log(\"parent :\" + v);\r\n            }\r\n        }\r\n    }\r\n});\r\n\r\nvar ChildView = ParentView.extend({\r\n    el : '<div><div data-kettle=\"foo\"></div></div>',\r\n    elements : {\r\n        \"foo\" : {\r\n            \"model.change:foo\" : function(m, v) {\r\n                console.log(\"child :\" + v);\r\n            }\r\n        }\r\n    }\r\n});\r\n\r\n\r\nchild = new ChildView(model : new Backbone.Model({foo : 'bar'})); //logs -> 'parent: bar' , 'child: bar'\r\n\r\n```\r\n## BBView\r\n\r\nFor some views the structure that Kettle provides might not be a good fit, in those situations a `BBView` can be used. `BBView` is a plain\r\n`Backbone.View` which has been extended and adapted slightly so that it can be included as part of a *collection view* or a *container view*.\r\nAnyone familiar with `Backbone.View` should feel right at home with `Kettle.BBView` the only caveat is that if a model or collection need\r\nto be changed on a `Kettle.BBView` it must be done via the `set` method. eg.: `bbView.set('model',newmodel)`;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## API\r\n\r\n### Element\r\n\r\nElement is the base object which all other objects inherit from.\r\n\r\n#### Properties\r\n\r\n`eventObjects` : A hash of all the event objects available to this view.  \r\n`view` : the parent view element  \r\n`el` : the DOM Node  \r\n`$el` : the `jQuery` Object  \r\n`model` : an alias for `eventObjects.model`  \r\n`collection` : an alias for `eventObjects.collection`  \r\n`state` :  an alias for `eventObjects.state`  \r\n\r\n#### Methods\r\n\r\n`bootstrapSubscriptions([\\*arguments])` : runs the bootstrapping logic on provided subscriptions. If no arguments provided runs it on all.  \r\n`hasSubscription` : returns a boolean if a subscription to a given *event object* exists.  \r\n`get(name)` : retrieve a specific *event object* by name\r\n`remove()` : remove the element from the DOM and unsubscribe from all events (default options: {silent: false})  \r\n`render(options)` : render the element (default options: {silent : false});  \r\n`set(name, eventObject, options)` : sets a new event object for a given name, unsbscribing from all events on the old event object,  \r\n    and subsribing to the new one. Default options : {silent: false, render: true}  \r\n`subscribe(name, event, fn)` : subscribes to a new event given the name of an event object, the event name and the function  \r\n`unsbscribe(name, event, fn, attribute)` : Unsubscribe from an *event object* by name, you can also unsubscribe from specific events or functions  \r\n    by providing further paremeters.  \r\n`unset()` : unset an *event object* by name  \r\n\r\n\r\n### View\r\n\r\n####Properties\r\n\r\n`elements`: all the children elements that are added to the view  \r\n\r\n#### Methods\r\n\r\n`addElement(name, element)` : Add a new element to the view, the added element will inherit all of the views *event objects* (except for 'el')  \r\n`remove()` : removes the element from the DOM and unsubscribes to all events, does the same on all child elements  \r\n`render(options)` : renders the view and all child elements, triggers a `render` event on the view.  \r\n`removeElement(element)` : removes an element from the view, element parameter can be either the name of the element or the element itself.  \r\n`set(name, eventObject, options)` : sets a new *event object* for a given name on the view as well as all the child elements.  \r\n\r\n### DomValue\r\n\r\n*dom value* is an element that holds a single value like a string. It is the Element used for two way binding.  \r\nWhen Constructing a view it is the Element that gets instantiated when a `bind` parameter is used in an *element* declaration, or when   \r\neither of `subview`, `subviews`, or `template` properties are omitted.  \r\n\r\n#### Methods\r\n\r\n`val()` returns the value of a DOM element  \r\n`val(value)` : sets a value on the DOM element, the method for setting the value differs based on what type of element it is.\r\n    For example if it is an input element the `value` attribute will be set, if it's a div or a span the `textContent` will be set,\r\n    if it is a checkbox the `checked` property will be set ... etc.  \r\n\r\n### CollectionView\r\n\r\n*collection view* manages multiple *sub views*, either automatically by watching a specific `Backbone.Collection` or manually.  \r\nWhen constructing a view it is the Element that gets instantiated when a `subviews ` parameter is used in an element declaration.\r\n\r\n#### Properties\r\n\r\n`subviews` : An array of views added to the *collection view*  \r\n\r\n#### Methods\r\n\r\n`addView(view, index)` : At a view at a given index (or at the end if omitted). Will also insert the view within the DOM element of the \r\n    *collection view*. If the view already exists in the collection, will remove it and re-add it to the correct index.  \r\n`bootstrapViewSubscriptions([\\*arguments])` : runs the bootstrapping logic on provided sub-view subscriptions. If no arguments provided runs it on all.  \r\n`empty` : remove all views from the *collection view*, this will effectively destroy them and unbind all their events.  \r\n`findWithEventObject(eventObject, name)` : find a view within a collection given a specific *event object*, if name is omitted it defaults to 'model'  \r\n`findWithElement(el)` : find a view within a collection given a DOM element (can also pass a $ object, but only first element will be used);  \r\n`hasViewSubscription` : returns a boolean if a subscription to a given *sub view* *event object* exists.  \r\n`insert(view, index)` : inserts a particular view in a particular index of the DOM. Meant for over-ridding if you wish to include your own logic\r\n    as to how the views should be inserted into the collection (eg. in reverse order);  \r\n`remove`: empty the *collection view* and remove it from the DOM, also unbinds all events.  \r\n`removeView(view)` : remove a specific view from the *collection view*, this will not unbind any events on the view.  \r\n`setEmptyView(view)` : set the view to display when the collection has no views.  \r\n`setTarget(collection, model, create)` : set the collection to keep track of (by name). In order to automatically bind add, remove, reset and sort events.  \r\n    The model name will be the name of the eventObject that the subview will hold for each model of the collection and finally the create parameter is a\r\n    function that given a model will return a new view.  \r\n`subscribeViews(name, event, fn)` : subscribes to a new event on a *sub view* given the name of an event object, the event name and the function  \r\n`unsbscribeViews(name, event, fn, attribute)` : Unsubscribe from a *sub views* *event object* by name, you can also unsubscribe from specific events or functions\r\n    by providing further paremeters.  \r\n\r\n### ContainerView\r\n\r\n*container view* is an element that contains within it exactly one view (or *dom value*, *collection view* etc). The view it contains can be swapped  \r\nfor another at any time, with the option to have it share *event objects* with the parent *container view*. When constructing a view a *container view*\r\nwill get instantiated when a `subview` parameter is used in an element declaration.\r\n\r\n#### Properties\r\n\r\n`subview` : the *sub view* that exists within the *container view*.  \r\n\r\n#### Methods\r\n\r\n`bootstrapViewSubscriptions([\\*arguments])` : runs the bootstrapping logic on provided sub-view subscriptions. If no arguments provided runs it on all.  \r\n`insert(view)` : Inserts a view within the body of the `contaienrView`. Meant for overriding if you wish to include your own logic as to how  \r\n`empty` : Empties out the container view, destroying the *sub view* if there is one  \r\n`hasViewSubscription` : returns a boolean if a subscription to a given *sub view* *event object* exists.  \r\n    the view should be inserted, by default its with `$el.append`.\r\n`remove` : remove the *container view* as well as the *sub view* it holds  from the DOM and unbinding all subscriptions.  \r\n`setSubView(view, synced)` : sets a new *sub view*, removing the old one if it exists and thus unbinding all its subscriptions. If the synced option is set to\r\n    `true` than the subview will inherit all *event objects* of the *container view*  \r\n`subscribeViews(name, event, fn)` : subscribes to a new event on a *sub view* given the name of an event object, the event name and the function  \r\n`unsbscribeViews(name, event, fn, attribute)` : Unsubscribe from a *sub view* *event object* by name, you can also unsubscribe from specific events or functions  \r\n    by providing further paremeters.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}